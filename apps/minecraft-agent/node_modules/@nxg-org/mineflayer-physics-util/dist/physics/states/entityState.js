"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityState = void 0;
const mineflayer_util_plugin_1 = require("@nxg-org/mineflayer-util-plugin");
const physicsUtils_1 = require("../../util/physicsUtils");
const vec3_1 = require("vec3");
const playerControls_1 = require("../player/playerControls");
const poses_1 = require("./poses");
const prismarine_nbt_1 = __importDefault(require("prismarine-nbt"));
const emptyVec = new vec3_1.Vec3(0, 0, 0);
class EntityState {
    // public effects: Effect[];
    // public statusEffectNames;
    constructor(ctx, height, halfWidth, pos, vel, onGround, yaw, pitch, control = playerControls_1.ControlStateHandler.DEFAULT()) {
        this.ctx = ctx;
        this.height = height;
        this.halfWidth = halfWidth;
        this.pos = pos;
        this.vel = vel;
        this.onGround = onGround;
        this.yaw = yaw;
        this.pitch = pitch;
        this.control = control;
        // may keep this, may not. Who knows?
        this.age = 0;
        this.onClimbable = false;
        this.isInWater = false;
        this.isInLava = false;
        this.isInWeb = false;
        this.elytraFlying = false;
        this.elytraEquipped = false;
        this.isCollidedHorizontally = false;
        this.isCollidedVertically = false;
        this.sneakCollision = false; //TODO
        //not sure what to do here, ngl.
        this.jumpTicks = 0;
        this.jumpQueued = false;
        this.fireworkRocketDuration = 0;
        // Input only (not modified)
        this.attributes = {}; //TODO
        this.isUsingItem = false;
        this.isUsingMainHand = false;
        this.isUsingOffHand = false;
        // effects
        this.effects = [];
        this.jumpBoost = 0;
        this.speed = 0;
        this.slowness = 0;
        this.dolphinsGrace = 0;
        this.slowFalling = 0;
        this.levitation = 0;
        this.depthStrider = 0;
        this.pose = poses_1.PlayerPoses.STANDING;
        this.supportingBlockPos = null;
    }
    static CREATE_FROM_BOT(ctx, bot) {
        return new EntityState(ctx, bot.entity.height, bot.entity.width / 2, bot.entity.position.clone(), bot.entity.velocity.clone(), bot.entity.onGround, bot.entity.yaw, bot.entity.pitch, playerControls_1.ControlStateHandler.COPY_BOT(bot)).updateFromBot(bot);
    }
    static CREATE_FROM_ENTITY(ctx, entity) {
        return new EntityState(ctx, entity.height, entity.width / 2, entity.position.clone(), entity.velocity.clone(), entity.onGround, entity.yaw, entity.pitch, playerControls_1.ControlStateHandler.DEFAULT()).updateFromEntity(entity);
    }
    static CREATE_FROM_PLAYER_STATE(ctx, state) {
        return new EntityState(ctx, state.height, state.halfWidth, state.pos.clone(), state.vel.clone(), state.onGround, state.yaw, state.pitch, state.control.clone()).updateFromRaw(state);
    }
    /**
     * Slightly different from the other two, use a pre-built object (assuming cloned) material.
     * @param ctx Physics instance.
     * @param raw CONSUMEABLE, build this with clones.
     * @returns PhysicsState
     */
    static CREATE_RAW(ctx, raw) {
        return new EntityState(ctx, raw.height, raw.halfWidth, raw.pos, raw.vel, raw.onGround, raw.yaw, raw.pitch, raw.control);
    }
    updateFromBot(bot) {
        this.updateFromEntity(bot.entity, true);
        this.control = playerControls_1.ControlStateHandler.COPY_BOT(bot);
        this.jumpTicks = bot.jumpTicks;
        this.jumpQueued = bot.jumpQueued;
        this.fireworkRocketDuration = bot.fireworkRocketDuration;
        return this;
    }
    updateFromEntity(entity, all = false) {
        var _a, _b, _c;
        if (all) {
            // most mobs don't have this defined, so ignore it (only self does).
            this.vel = entity.velocity.clone();
            this.onGround = entity.onGround;
            this.onClimbable = entity.onClimbable;
            this.isInWater = entity.isInWater;
            this.isInLava = entity.isInLava;
            this.isInWeb = entity.isInWeb;
            this.elytraFlying = entity.elytraFlying;
            this.isCollidedHorizontally = entity.isCollidedHorizontally;
            this.isCollidedVertically = entity.isCollidedVertically;
            this.sneakCollision = false; //TODO
            this.attributes || (this.attributes = entity.attributes);
            this.elytraEquipped = entity.equipment[4] && ((_a = entity.equipment[4]) === null || _a === void 0 ? void 0 : _a.name.includes("elytra"));
            this.elytraFlying = this.elytraEquipped && this.elytraFlying;
        }
        this.pos = entity.position.clone();
        //not sure what to do here, ngl.
        this.jumpTicks || (this.jumpTicks = 0);
        this.jumpQueued || (this.jumpQueued = false);
        // Input only (not modified)
        this.yaw = entity.yaw;
        this.pitch = entity.pitch;
        this.control || (this.control = playerControls_1.ControlStateHandler.DEFAULT());
        this.isUsingItem = (0, physicsUtils_1.isEntityUsingItem)(entity, this.ctx.supportFeature);
        this.isUsingMainHand = !(0, physicsUtils_1.whichHandIsEntityUsingBoolean)(entity, this.ctx.supportFeature) && this.isUsingItem;
        this.isUsingOffHand = (0, physicsUtils_1.whichHandIsEntityUsingBoolean)(entity, this.ctx.supportFeature) && this.isUsingItem;
        // effects
        this.effects = entity.effects;
        this.jumpBoost = this.ctx.getEffectLevel(physicsUtils_1.CheapEffects.JUMP_BOOST, this.effects);
        this.speed = this.ctx.getEffectLevel(physicsUtils_1.CheapEffects.SPEED, this.effects);
        this.slowness = this.ctx.getEffectLevel(physicsUtils_1.CheapEffects.SLOWNESS, this.effects);
        this.dolphinsGrace = this.ctx.getEffectLevel(physicsUtils_1.CheapEffects.DOLPHINS_GRACE, this.effects);
        this.slowFalling = this.ctx.getEffectLevel(physicsUtils_1.CheapEffects.SLOW_FALLING, this.effects);
        this.levitation = this.ctx.getEffectLevel(physicsUtils_1.CheapEffects.LEVITATION, this.effects);
        // armour enchantments
        //const boots = bot.inventory.slots[8];
        const boots = entity.equipment[5];
        if (boots && boots.nbt) {
            const simplifiedNbt = prismarine_nbt_1.default.simplify(boots.nbt);
            const enchantments = (_c = (_b = simplifiedNbt.Enchantments) !== null && _b !== void 0 ? _b : simplifiedNbt.ench) !== null && _c !== void 0 ? _c : [];
            this.depthStrider = this.ctx.getEnchantmentLevel(physicsUtils_1.CheapEnchantments.DEPTH_STRIDER, enchantments);
        }
        else {
            this.depthStrider = 0;
        }
        this.pose || (this.pose = poses_1.PlayerPoses.STANDING);
        return this;
    }
    updateFromRaw(other) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
        this.onGround = (_a = other.onGround) !== null && _a !== void 0 ? _a : this.onGround;
        this.onClimbable = (_b = other.onClimbable) !== null && _b !== void 0 ? _b : this.onClimbable;
        this.sneakCollision = (_c = other.sneakCollision) !== null && _c !== void 0 ? _c : this.sneakCollision;
        this.isUsingItem = (_d = other.isUsingItem) !== null && _d !== void 0 ? _d : this.isUsingItem;
        this.jumpBoost = (_e = other.jumpBoost) !== null && _e !== void 0 ? _e : this.jumpBoost;
        this.speed = (_f = other.speed) !== null && _f !== void 0 ? _f : this.speed;
        this.slowness = (_g = other.slowness) !== null && _g !== void 0 ? _g : this.slowness;
        this.dolphinsGrace = (_h = other.dolphinsGrace) !== null && _h !== void 0 ? _h : this.dolphinsGrace;
        this.slowFalling = (_j = other.slowFalling) !== null && _j !== void 0 ? _j : this.slowFalling;
        this.levitation = (_k = other.levitation) !== null && _k !== void 0 ? _k : this.levitation;
        this.depthStrider = (_l = other.depthStrider) !== null && _l !== void 0 ? _l : this.depthStrider;
        this.effects = (_m = other.effects) !== null && _m !== void 0 ? _m : this.effects;
        this.isCollidedHorizontally = (_o = other.isCollidedHorizontally) !== null && _o !== void 0 ? _o : this.isCollidedHorizontally;
        this.isCollidedVertically = (_p = other.isCollidedVertically) !== null && _p !== void 0 ? _p : this.isCollidedVertically;
        this.isInWater = (_q = other.isInWater) !== null && _q !== void 0 ? _q : this.isInWater;
        this.isInLava = (_r = other.isInLava) !== null && _r !== void 0 ? _r : this.isInLava;
        this.isInWeb = (_s = other.isInWeb) !== null && _s !== void 0 ? _s : this.isInWeb;
        this.elytraFlying = (_t = other.elytraFlying) !== null && _t !== void 0 ? _t : this.elytraFlying;
        this.elytraEquipped = (_u = other.elytraEquipped) !== null && _u !== void 0 ? _u : this.elytraEquipped;
        return this;
    }
    applyToBot(bot) {
        bot.entity.position.set(this.pos.x, this.pos.y, this.pos.z);
        bot.entity.velocity.set(this.vel.x, this.vel.y, this.vel.z);
        bot.entity.onGround = this.onGround;
        bot.entity.onClimbable = this.onClimbable;
        bot.entity.yaw = this.yaw;
        bot.entity.pitch = this.pitch;
        bot.controlState = this.control;
        bot.jumpTicks = this.jumpTicks;
        bot.jumpQueued = this.jumpQueued;
        bot.fireworkRocketDuration = this.fireworkRocketDuration;
        bot.entity.isInWater = this.isInWater;
        bot.entity.isInLava = this.isInLava;
        bot.entity.isInWeb = this.isInWeb;
        bot.entity.elytraFlying = this.elytraFlying;
        bot.entity.elytraEquipped = this.elytraEquipped;
        bot.entity.isCollidedHorizontally = this.isCollidedHorizontally;
        bot.entity.isCollidedVertically = this.isCollidedVertically;
        bot.entity.sneakCollision = this.sneakCollision;
        bot.entity.pose = this.pose;
        this.control.applyControls(bot);
        return this;
    }
    /**
     * No idea when you'd use this.
     */
    applyToEntity(entity) {
        entity.position = this.pos;
        entity.velocity = this.vel;
        // entity.position.set(this.position.x, this.position.y, this.position.z);
        // entity.velocity.set(this.velocity.x, this.velocity.y, this.velocity.z);
        entity.onGround = this.onGround;
        entity.onClimbable = this.onClimbable;
        entity.yaw = this.yaw;
        entity.pitch = this.pitch;
        return this;
    }
    clone() {
        const other = new EntityState(this.ctx, this.height, this.halfWidth, this.pos.clone(), this.vel.clone(), this.onGround, this.yaw, this.pitch, this.control.clone());
        other.onClimbable = this.onClimbable;
        other.age = this.age;
        other.isCollidedHorizontally = this.isCollidedHorizontally;
        other.isCollidedVertically = this.isCollidedVertically;
        other.isInWater = this.isInWater;
        other.isInLava = this.isInLava;
        other.isInWeb = this.isInWeb;
        other.elytraFlying = this.elytraFlying;
        other.elytraEquipped = this.elytraEquipped;
        other.fireworkRocketDuration = this.fireworkRocketDuration;
        other.jumpTicks = this.jumpTicks;
        other.jumpQueued = this.jumpQueued;
        other.sneakCollision = this.sneakCollision;
        other.attributes = this.attributes;
        other.isUsingItem = this.isUsingItem;
        other.isUsingMainHand = this.isUsingMainHand;
        other.isUsingOffHand = this.isUsingOffHand;
        other.jumpBoost = this.jumpBoost;
        other.speed = this.speed;
        other.slowness = this.slowness;
        other.dolphinsGrace = this.dolphinsGrace;
        other.slowFalling = this.slowFalling;
        other.levitation = this.levitation;
        other.depthStrider = this.depthStrider;
        other.effects = this.effects;
        other.pose = this.pose;
        return other;
    }
    merge(other) {
        this.age = other.age;
        this.pos = other.pos.clone();
        this.vel = other.vel.clone();
        this.onGround = other.onGround;
        this.onClimbable = other.onClimbable;
        this.isCollidedHorizontally = other.isCollidedHorizontally;
        this.isCollidedVertically = other.isCollidedVertically;
        this.isInWater = other.isInWater;
        this.isInLava = other.isInLava;
        this.isInWeb = other.isInWeb;
        this.elytraFlying = other.elytraFlying;
        this.elytraEquipped = other.elytraEquipped;
        this.fireworkRocketDuration = other.fireworkRocketDuration;
        this.jumpTicks = other.jumpTicks;
        this.jumpQueued = other.jumpQueued;
        this.sneakCollision = other.sneakCollision;
        this.attributes = other.attributes;
        this.isUsingItem = other.isUsingItem;
        this.isUsingMainHand = other.isUsingMainHand;
        this.isUsingOffHand = other.isUsingOffHand;
        this.jumpBoost = other.jumpBoost;
        this.speed = other.speed;
        this.slowness = other.slowness;
        this.dolphinsGrace = other.dolphinsGrace;
        this.slowFalling = other.slowFalling;
        this.levitation = other.levitation;
        this.depthStrider = other.depthStrider;
        this.effects = other.effects;
        this.pose = other.pose;
        return this;
    }
    clearControlStates() {
        this.control = playerControls_1.ControlStateHandler.DEFAULT();
        return this;
    }
    /**
     * needs to be updated.
     * @returns AABB
     */
    getBB() {
        const hW = this.halfWidth;
        return new mineflayer_util_plugin_1.AABB(this.pos.x - hW, this.pos.y, this.pos.z - hW, this.pos.x + hW, this.pos.y + this.height, this.pos.z + hW);
    }
    lookAt(vec3) {
        const dx = vec3.x - this.pos.x;
        const dy = vec3.y - this.pos.y;
        const dz = vec3.z - this.pos.z;
        this.yaw = Math.atan2(dz, dx) * 180 / Math.PI - 90;
        this.pitch = -Math.atan2(dy, Math.sqrt(dx * dx + dz * dz)) * 180 / Math.PI;
    }
    look(yaw, pitch) {
        this.yaw = yaw;
        this.pitch = pitch;
    }
}
exports.EntityState = EntityState;
