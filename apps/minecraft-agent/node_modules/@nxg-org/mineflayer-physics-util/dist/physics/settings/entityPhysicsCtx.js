"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EPhysicsCtx = exports.emptyVec = void 0;
const mineflayer_util_plugin_1 = require("@nxg-org/mineflayer-util-plugin");
const prismarine_entity_1 = __importDefault(require("prismarine-entity"));
const vec3_1 = require("vec3");
const physicsUtils_1 = require("../../util/physicsUtils");
const states_1 = require("../states");
const poses_1 = require("../states/poses");
const entity_physics_json_1 = __importDefault(require("../info/entity_physics.json"));
const physicsSettings_1 = require("./physicsSettings");
const states_2 = require("../states");
function load(data) {
    EPhysicsCtx.mcData = data;
    EPhysicsCtx.entityData = data["entitiesByName"];
    EPhysicsCtx.mobData = data["mobs"];
    EPhysicsCtx.entityConstructor = prismarine_entity_1.default(data.version.minecraftVersion);
}
exports.emptyVec = new vec3_1.Vec3(0, 0, 0);
class EPhysicsCtx {
    constructor(ctx, worldSettings, pose, state, entityType = physicsUtils_1.DefaultPlayer) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        this.ctx = ctx;
        this.worldSettings = worldSettings;
        this.pose = pose;
        this.state = state;
        this.entityType = entityType;
        this.stepHeight = 0;
        this.gravity = 0.08;
        this.airdrag = Math.fround(1 - 0.0);
        this.airborneInertia = 0.91;
        this.airborneAccel = 0.02;
        this.waterInertia = 0.8;
        this.sprintWaterInertia = 0.9;
        this.lavaInertia = 0.5;
        this.liquidAccel = 0.02;
        this.gravityThenDrag = false;
        this.useControls = false;
        this.doSolidCollisions = true;
        this.doLiquidCollisions = true;
        this.collisionBehavior = {
            blockEffects: false,
            affectedAfterCollision: true,
        };
        this.position = state.pos;
        this.velocity = state.vel;
        // TODO cleanup all of this code.
        if (entityType.type === "player" || !!EPhysicsCtx.mobData[entityType.id]) {
            // @ts-expect-error
            const additional = entity_physics_json_1.default.living_entities[entityType.type];
            Object.assign(this, entity_physics_json_1.default.living_entities.default, additional);
        }
        else if (entityType.name.includes("experience_orb")) {
            Object.assign(this, entity_physics_json_1.default.other.default);
        }
        else if (entityType.name.includes("spit")) {
            Object.assign(this, entity_physics_json_1.default.projectiles.default, entity_physics_json_1.default.projectiles.llama_spit);
        }
        else {
            switch (entityType.type) {
                case "water_creature":
                case "animal":
                case "hostile":
                case "mob":
                    this.gravity = 0.08;
                    this.airdrag = Math.fround(1 - 0.02);
                    this.gravityThenDrag = true;
                    this.useControls = true;
                    this.stepHeight = 1.0;
                    this.collisionBehavior = {
                        blockEffects: true,
                        affectedAfterCollision: true,
                    };
                    break;
                case "projectile":
                    this.gravity = 0.03;
                    this.airdrag = Math.fround(1 - 0.01);
                    this.airborneInertia = this.airdrag;
                    this.airborneAccel = 0.06;
                    this.waterInertia = 0.25;
                    this.lavaInertia = 0;
                    this.liquidAccel = 0.02;
                    this.collisionBehavior = {
                        blockEffects: false,
                        affectedAfterCollision: false,
                    };
                    if (entity_physics_json_1.default.projectiles[entityType.name]) {
                        Object.assign(this, entity_physics_json_1.default.projectiles[entityType.name]);
                    }
                    break;
                case "orb":
                    this.gravity = 0.03;
                    this.airdrag = Math.fround(1 - 0.02);
                    this.collisionBehavior = {
                        blockEffects: false,
                        affectedAfterCollision: true,
                    };
                    break;
                case "other":
                    if (entityType.name.includes("minecart") || entityType.name.includes("boat")) {
                        Object.assign(this, entity_physics_json_1.default.dead_vehicles.default, entityType.name === "boat" ? entity_physics_json_1.default.dead_vehicles.boat : undefined);
                    }
                    else if (((_a = entityType.name) === null || _a === void 0 ? void 0 : _a.includes("block")) || ((_b = entityType.name) === null || _b === void 0 ? void 0 : _b.includes("tnt"))) {
                        Object.assign(this, entity_physics_json_1.default.blocks.default);
                    }
                    else if (((_c = entityType.name) === null || _c === void 0 ? void 0 : _c.includes("egg")) ||
                        ((_d = entityType.name) === null || _d === void 0 ? void 0 : _d.includes("snowball")) ||
                        ((_e = entityType.name) === null || _e === void 0 ? void 0 : _e.includes("potion")) ||
                        ((_f = entityType.name) === null || _f === void 0 ? void 0 : _f.includes("pearl"))) {
                        Object.assign(this, entity_physics_json_1.default.projectiles.default);
                    }
                    else if ((_g = entityType.name) === null || _g === void 0 ? void 0 : _g.includes("orb")) {
                        Object.assign(this, entity_physics_json_1.default.other.default);
                    }
                    else if ((_h = entityType.name) === null || _h === void 0 ? void 0 : _h.includes("bobber")) {
                        Object.assign(this, entity_physics_json_1.default.projectiles.default, entity_physics_json_1.default.projectiles.fishing_bobber);
                    }
                    else if ((_j = entityType.name) === null || _j === void 0 ? void 0 : _j.includes("spit")) {
                        Object.assign(this, entity_physics_json_1.default.projectiles.default, entity_physics_json_1.default.projectiles.llama_spit);
                    }
                    else if (((_k = entityType.name) === null || _k === void 0 ? void 0 : _k.includes("arrow")) || ((_l = entityType.name) === null || _l === void 0 ? void 0 : _l.includes("trident"))) {
                        Object.assign(this, entity_physics_json_1.default.projectiles.default, entityType.name.includes("arrow") ? entity_physics_json_1.default.projectiles.arrow : entity_physics_json_1.default.projectiles.trident);
                    }
                    else if (((_m = entityType.name) === null || _m === void 0 ? void 0 : _m.includes("fireball")) || ((_o = entityType.name) === null || _o === void 0 ? void 0 : _o.includes("skull"))) {
                        Object.assign(this, entity_physics_json_1.default.shot_entities.default);
                    }
            }
        }
        if (ctx.supportFeature("independentLiquidGravity")) {
            this.waterGravity = 0.02;
            this.lavaGravity = 0.02;
        }
        else if (ctx.supportFeature("proportionalLiquidGravity")) {
            this.waterGravity = this.gravity / 16;
            this.lavaGravity = this.gravity / 4;
        }
        else {
            this.waterGravity = 0.005;
            this.lavaGravity = 0.02;
        }
    }
    static FROM_BOT(ctx, bot, settings) {
        settings !== null && settings !== void 0 ? settings : (settings = new physicsSettings_1.PhysicsWorldSettings(bot.registry));
        return new EPhysicsCtx(ctx, settings, (0, states_2.getPose)(bot.entity), new states_2.PlayerState(ctx, bot));
    }
    static FROM_ENTITY(ctx, entity, settings) {
        settings !== null && settings !== void 0 ? settings : (settings = new physicsSettings_1.PhysicsWorldSettings(ctx.data));
        return new EPhysicsCtx(ctx, settings, (0, states_2.getPose)(entity), states_1.EntityState.CREATE_FROM_ENTITY(ctx, entity), EPhysicsCtx.entityData[entity.name]);
    }
    static FROM_ENTITY_TYPE(ctx, entityType, options = {}, settings) {
        // unneeded for most entities, use a default.
        settings !== null && settings !== void 0 ? settings : (settings = new physicsSettings_1.PhysicsWorldSettings(ctx.data));
        const newE = (0, physicsUtils_1.applyMdToNewEntity)(EPhysicsCtx, entityType, options);
        return new EPhysicsCtx(ctx, settings, poses_1.PlayerPoses.STANDING, states_1.EntityState.CREATE_FROM_ENTITY(ctx, newE), entityType);
    }
    static FROM_ENTITY_STATE(ctx, entityState, entityType, settings) {
        settings !== null && settings !== void 0 ? settings : (settings = new physicsSettings_1.PhysicsWorldSettings(ctx.data));
        return new EPhysicsCtx(ctx, settings, entityState.pose, entityState, entityType);
    }
    clone() {
        return new EPhysicsCtx(this.ctx, this.worldSettings, this.state.pose, this.state.clone(), this.entityType);
    }
    get height() {
        var _a, _b;
        if (this.entityType.type === "player") {
            return poses_1.playerPoseCtx[(_a = this.pose) !== null && _a !== void 0 ? _a : 0].height;
        }
        return (_b = this.entityType.height) !== null && _b !== void 0 ? _b : 0;
    }
    get width() {
        var _a, _b;
        if (this.entityType.type === "player") {
            return poses_1.playerPoseCtx[(_a = this.pose) !== null && _a !== void 0 ? _a : 0].width;
        }
        return (_b = this.entityType.width) !== null && _b !== void 0 ? _b : 0;
    }
    getHalfWidth() {
        return this.width / 2;
    }
    getCurrentBBWithPose() {
        const halfWidth = this.getHalfWidth();
        return new mineflayer_util_plugin_1.AABB(this.position.x - halfWidth, this.position.y, this.position.z - halfWidth, this.position.x + halfWidth, this.position.y + this.height, this.position.z + halfWidth);
    }
    getBBWithPose(position) {
        const halfWidth = this.getHalfWidth();
        return new mineflayer_util_plugin_1.AABB(position.x - halfWidth, position.y, position.z - halfWidth, position.x + halfWidth, position.y + this.height, position.z + halfWidth);
    }
    getBB(position) {
        var _a;
        const halfWidth = this.entityType.width ? this.entityType.width / 2 : 0;
        return new mineflayer_util_plugin_1.AABB(position.x - halfWidth, position.y, position.z - halfWidth, position.x + halfWidth, position.y + ((_a = this.entityType.height) !== null && _a !== void 0 ? _a : 0), position.z + halfWidth);
    }
}
exports.EPhysicsCtx = EPhysicsCtx;
EPhysicsCtx.loadData = load;
