import { AABB } from "@nxg-org/mineflayer-util-plugin";
import md from "minecraft-data";
import { Block } from "prismarine-block";
import { Effect } from "prismarine-entity";
import { Vec3 } from "vec3";
import { CheapEffects, CheapEnchantments, makeSupportFeature } from "../../util/physicsUtils";
import { EPhysicsCtx } from "../settings/entityPhysicsCtx";
import { IEntityState } from "../states";
import { IPhysics } from "./IPhysics";
import { PlayerState } from "../states";
import type { world } from "prismarine-world";
type World = world.WorldSync;
/**
 * Looking at this code, it's too specified towards players.
 *
 * I will eventually split this code into PlayerState and bot.entityState, where bot.entityState contains fewer controls.
 */
export declare class BotcraftPhysics implements IPhysics {
    data: md.IndexedData;
    movementSpeedAttribute: string;
    jumpStrengthAttribute: string;
    movementEfficiencyAttribute: string;
    waterMovementEfficiencyAttribute: string;
    stepHeightAttribute: string;
    supportFeature: ReturnType<typeof makeSupportFeature>;
    blockSlipperiness: {
        [name: string]: number;
    };
    protected bedId: number;
    protected slimeBlockId: number;
    protected soulsandId: number;
    protected berryBushId: number;
    protected powderSnowId: number;
    protected honeyblockId: number;
    protected webId: number;
    protected waterId: number;
    protected lavaId: number;
    protected ladderId: number;
    protected vineId: number;
    protected scaffoldId: number;
    protected bubblecolumnId: number;
    protected waterLike: Set<number>;
    readonly statusEffectNames: {
        [type in CheapEffects]: string;
    };
    readonly enchantmentNames: {
        [type in CheapEnchantments]: string;
    };
    constructor(mcData: md.IndexedData);
    getEntityBB(entity: EPhysicsCtx, pos: {
        x: number;
        y: number;
        z: number;
    }): AABB;
    setPositionToBB(entity: EPhysicsCtx, bb: AABB, pos: {
        x: number;
        y: number;
        z: number;
    }): void;
    getSurroundingBBs(queryBB: AABB, world: World, underlying?: boolean): AABB[];
    getWaterInBBs(bb: AABB, world: World): AABB[];
    getEffectLevel(wantedEffect: CheapEffects, effects: Effect[]): number;
    getEnchantmentLevel(wantedEnchantment: CheapEnchantments, enchantments: any[]): any;
    private verGreaterThan;
    private verLessThan;
    private worldIsFree;
    /**
     * 1:1 copy of the original physicsTick function from botcraft
     * https://github.com/adepierre/Botcraft/blob/6c572071b0237c27a85211a246ce10565ef4d80f/botcraft/src/Game/Physics/PhysicsManager.cpp#L277
     *
     *
     * @param ctx
     * @param world
     */
    private physicsTick;
    /**
     * Assume later than 1.13.2 before calling this function.
     * @param player
     * @param world
     */
    private updatePoses;
    private fluidPhysics;
    getFlow(block: Block, world: World): Vec3;
    getLiquidHeightPcent(block: Block): number;
    getRenderedDepth(block: Block): number;
    private updateSwimming;
    private localPlayerAIStep;
    private inputsToCrouch;
    private isSwimmingAndNotFlying;
    private inputsToSprint;
    private canStartSprinting;
    private hasEnoughFoodToSprint;
    private vehicleCanSprint;
    private isSwimming;
    private shouldStopRunSprinting;
    private shouldStopSwimSprinting;
    /**
     * TODO: almost certainly unfinished.
     * @param player
     * @param value
     */
    setSprinting(ctx: EPhysicsCtx, value: boolean): void;
    private inputsToFly;
    private inputsToJump;
    private getBlockBelowAffectingMovement;
    /**
     * Taken from original physics impl.
     * @param entity
     * @returns
     */
    getMovementSpeedAttribute(entity: EPhysicsCtx): number;
    /**
     * Assume EPhysicsCtx is wrapping a PlayerState.
     * @param ctx
     * @param world
     */
    movePlayer(ctx: EPhysicsCtx, world: World): void;
    applyMovement(ctx: EPhysicsCtx, world: World): void;
    isCollidedHorizontallyMinor(state: IEntityState, var1: Vec3): boolean;
    checkInsideBlocks(player: PlayerState, world: World): void;
    collideBoundingBox(world: World, bb: AABB, movement: Vec3, colliders?: AABB[]): Vec3;
    private collideWithShapes;
    shapeCollide(axis: number, bb: AABB, colliders: AABB[], movement: number): number;
    /**
   * Handles collision detection and response along a single axis.
   * @param axis The axis to check for collision (0 = X, 1 = Y, 2 = Z)
   * @param bb The bounding box that's moving
   * @param movement The proposed movement amount along the specified axis
   * @param colliders Array of AABBs to check for collisions with
   * @returns The adjusted movement amount that prevents collisions
   */
    /**
     * Handles collision detection and response along a single axis.
     * @param axis The axis to check for collision (0 = X, 1 = Y, 2 = Z)
     * @param bb The bounding box that's moving
     * @param movement The proposed movement amount along the specified axis
     * @param colliders Array of AABBs to check for collisions with
     * @returns The adjusted movement amount that prevents collisions
     */
    private voxelShapeCollide;
    collideOneAxis(movedAABB: AABB, movement: Vec3, axis: number, colliders: AABB[]): void;
    applyInputs(inputStrength: number, player: PlayerState): void;
    isInClimbable(player: PlayerState, world: World): boolean;
    getSupportingBlockPos(world: World, feetSliceAABB: AABB): Vec3 | null;
    simulate(entity: EPhysicsCtx, world: World): IEntityState;
}
export {};
