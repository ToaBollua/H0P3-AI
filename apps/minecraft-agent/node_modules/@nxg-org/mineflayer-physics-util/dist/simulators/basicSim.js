"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasicSim = void 0;
const baseSimulator_1 = require("./baseSimulator");
class BasicSim extends baseSimulator_1.BaseSimulator {
    constructor(ctx) {
        super(ctx);
        this.ctx = ctx;
    }
    // public simXTicksRaw(mdEntity: md.Entity, world: any, ticks: number = 5, options: Partial<Entity> = {}) {
    //     return this.simXTicks(applyMdToNewEntity(EPhysicsCtx, mdEntity, options), world, ticks);
    // }
    // public simXTicks(entity: Entity, world: any, ticks: number) {
    //     return this.simulateUntil(
    //         (state) => false,
    //         () => {},
    //         () => {},
    //         EPhysicsCtx.FROM_ENTITY(this.ctx, entity),
    //         world,
    //         ticks
    //     );
    // }
    simXTicksPrebuilt(ctx, world, ticks) {
        return this.simulateUntil((state) => false, () => { }, () => { }, ctx, world, ticks);
    }
    // public simUntilOnGroundRaw(mdEntity: md.Entity, world: any, ticks: number = 5, options: Partial<Entity> = {}) {
    //     return this.simUntilOnGround(applyMdToNewEntity(EPhysicsCtx, mdEntity, options), world, ticks);
    // }
    // public simUntilOnGround(entity: Entity, world: any, ticks: number = 5) {
    //     return this.simulateUntil(
    //         (state) => state.onGround === true,
    //         () => {},
    //         () => {},
    //         EPhysicsCtx.FROM_ENTITY(this.ctx, entity),
    //         world,
    //         ticks
    //     );
    // }
    simUntilOnGroundPrebuilt(ctx, world, ticks = 5) {
        return this.simulateUntil((state) => state.onGround === true, () => { }, () => { }, ctx, world, ticks);
    }
    // public simUntilDestinationRaw(mdEntity: md.Entity, destination: Vec3, world: any, ticks: number = 5, options: Partial<Entity> = {}) {
    //     return this.simUntilDestination(applyMdToNewEntity(EPhysicsCtx, mdEntity, options), destination, world, ticks);
    // }
    // public simUntilDestination(entity: Entity, destination: Vec3, world: any, ticks: number = 10) {
    //     return this.simulateUntil(
    //         BasicSim.getReached(destination),
    //         () => {},
    //         () => {},
    //         EPhysicsCtx.FROM_ENTITY(this.ctx, entity),
    //         world,
    //         ticks
    //     );
    // }
    simUntilDestinationPrebuilt(ctx, destination, world, ticks = 10) {
        return this.simulateUntil(BasicSim.getReached(destination), () => { }, () => { }, ctx, world, ticks);
    }
}
exports.BasicSim = BasicSim;
