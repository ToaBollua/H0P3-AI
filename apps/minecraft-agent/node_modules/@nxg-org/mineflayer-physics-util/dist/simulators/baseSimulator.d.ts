import { ControlStateHandler } from "../physics/player";
import { EPhysicsCtx } from "../physics/settings";
import { EntityState, IEntityState } from "../physics/states";
import { IPhysics } from "../physics/engines";
import { Entity } from "prismarine-entity";
import { Vec3 } from "vec3";
export type SimulationGoal<State extends IEntityState = IEntityState> = (state: State, ticks: number) => boolean | ((state: State) => boolean);
export type OnGoalReachFunction<State extends IEntityState = IEntityState> = (state: State) => void;
export type Controller<State extends IEntityState = IEntityState> = (state: State, ticks: number) => void;
export declare class BaseSimulator<State extends IEntityState = IEntityState> {
    readonly ctx: IPhysics;
    constructor(ctx: IPhysics);
    predictGenerator(simCtx: EPhysicsCtx<State>, world: any, ticks?: number, controls?: ControlStateHandler): Generator<IEntityState, EPhysicsCtx<State>, unknown>;
    predictForward(target: Entity, world: any, ticks?: number, controls?: ControlStateHandler): EntityState;
    predictForwardRaw(simCtx: EPhysicsCtx<State>, world: any, ticks?: number, controls?: ControlStateHandler): State;
    simulateUntil(goal: SimulationGoal<State>, onGoalReach: OnGoalReachFunction<State>, controller: Controller<State>, simCtx: EPhysicsCtx<State>, world: any, ticks?: number): State;
    static getReached<State extends IEntityState = IEntityState>(...path: Vec3[]): SimulationGoal<State>;
    static getCleanupPosition<State extends IEntityState = IEntityState>(...path: Vec3[]): OnGoalReachFunction<State>;
    static buildFullController<State extends IEntityState = IEntityState>(...controllers: Controller<State>[]): Controller<State>;
    static buildAnyGoal<State extends IEntityState = IEntityState>(...goals: SimulationGoal<State>[]): SimulationGoal<State>;
    static buildAllGoal<State extends IEntityState = IEntityState>(...goals: SimulationGoal<State>[]): SimulationGoal<State>;
}
